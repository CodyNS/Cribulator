<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodyNS' Cribulator</title>
    <!-- <link rel="stylesheet" type="text/css" href="style-codymod.css"/> -->
    <style>
        body{background-color: #74859f; padding: 70px 10%}
        #theForm textarea{display: block; margin-bottom: 35px; padding: 6px; width: 100%; background-color: #212121; color: #FFF; font-size: 1.4em}
        #theForm label{display: block; padding-bottom: 9px; font-size: 1.5em}
        #theForm input{display: block;  width: 100%; padding: 6px; background-color: #dfffe4; font-size: 1.5em}
       
    </style>
</head>

<body>
    <form id="theForm" onsubmit="return processInput(this)">
        <textarea rows="14" cols="" name="outputbox"></textarea>
        <label for="inputbox">Input area: </label>
        <input type="text" id="inputbox" name="inputbox">
        <!-- <br><input type="submit" value="Submit"> -->
    </form> 

    <script>
        let theForm = document.querySelector("#theForm");
        let mostRecentInput = "";
        let newInputExists = false;  // is checked by the getUserInput() function to detect when to proceed

        function processInput(form) {
            newInputExists = true;
            mostRecentInput = form.inputbox.value;
            form.outputbox.value += mostRecentInput + "\n";
            form.inputbox.value = "";
            form.outputbox.scrollTop = form.outputbox.scrollHeight;
            return false;  // prevents page from reloading on form submission
        }

        class Player {
            constructor(name, indentName) {
                this.name = name;  // string
                this.indtAdjstdName = indentName;  // string

                this.legacyWins = 0; // int
                this.legacyCribSum = 0;  // int. Combined value (Molly + Johnny)
                this.legacyNumHands = 0;  // int

                this.histoCutsForFirstCribAT = Array(13).fill(0);  // vector<int>
                this.histoCutsForMyCribAT = Array(13).fill(0);  // vector<int> - aka starter cards
                this.histoHandPtsAT = Array(30).fill(0);  // vector<int>
                this.histoCribPtsAT = Array(30).fill(0);  // vector<int>
                this.histoWinMarginsAT = Array(120).fill(0);  // vector<int>
                this.numFirstCribsAT = 0;  // int
                this.numFirstCribsWonAT = 0;  // int
                this.peggedPtsAt = 0;  // int
                this.unusedPtsAT = [0,0,0,0];  // vector<int> - hand, crib, nibs, pegged
                this.macrogamePtsAT = 0;  // int
                this.numSessionsPlayedAT = 0;  // int
                this.numHandsAT = 0;  // int
                this.numCribsAT = 0;  // int
                this.gamesPlayedAT = 0;  // int
                this.winsAT = 0;  // int
                this.nobsAT = 0;  // int
                this.FOKsAT = 0;  // int. four-of-a-kinds
                this.flushesAT = 0;  // int
                this.superFlushesAT = 0;  // int

                this.cutsForFirstCribToday = [];  // vector<String>
                this.histoCutsForMyCribToday = Array(13).fill(0);  // vector<int>
                this.histoHandPtsToday = Array(30).fill(0);  // vector<int>
                this.histoCribPtsToday = Array(30).fill(0);   // vector<int>
                this.winMarginsToday = [];  // vector<int>
                this.numFirstCribsToday = 0;  // int
                this.numFirstCribsWonToday = 0;  // int
                this.peggedPtsToday = 0;  // int
                this.unusedPtsToday = [0,0,0,0];  // vector<int>
                this.losingPositionToday = 0;  // int
                this.macrogamePtsToday = 0;  // int
                this.numHandsToday = 0;  // int
                this.numCribsToday = 0;  // int
                this.gamesPlayedToday = 0;  // int
                this.winsToday = 0;  // int
                this.nobsToday = 0;  // int
                this.FOKsToday = 0;  // int
                this.flushesToday = 0;  // int
                this.superFlushesToday = 0;  // int

                this.handPtsThisGame = 0;  // int
                this.cribPtsThisGame = 0;  // int
                this.numNibsThisGame = 0;  // int.  x2 to get pts
                this.peggedPtsThisGame = 0;  // int
                this.unusedPtsThisGame = [0,0,0,0];  // vector<int> 
                this.numHandsThisGame = 0;  // int
                this.numCribsThisGame = 0;  // int
            } // constructor
        } // class

        // CONSTANTS -------------------------------
        const USE_LEGACY_DATA = false;  // flag that enables/disables the use of legacy crib data
                                        // aka data from Jan 1 . 17 before this program was complete
                                        // and all data was able to be collected.
        const SCREEN_WIDTH = 120;
        const SAVE_FILE_NAME = "cribulator_player_save_data.txt";  // BLAH: what do I do with these names now? Use a DB instead.
        const BLANK_SAVE_FILE_INPUT_NAME = "test_(blank)_save_data.txt";
        const BLANK_SAVE_FILE_OUTPUT_NAME = "test_save_data_output.txt";
        const VAR_PREFIX = "### ";
        const HAND = 0; // these 4 used for excess point variable indeces
        const CRIB = 1;
        const NIBS = 2;
        const PEGGED = 3; 
        const USER_WANTS_TO_END_SESSION = false;
        const DEALER_WINS_FROM_NIBS = true;
        const CRIBBER_WINS = true;
        const NON_CRIBBER_WINS = true;
        const SOMEONE_HAS_WON = true;
        const INDENTATION = "\t\t\t";  // BLAH why aren't the following ones capitalized?
        const CORRECTION_VARIATIONS = ["fix", "correct", "undo", "redo", "mistake", "oops", "woops"];  // vector<string>, same for rest
        const HISTO_VARIATIONS = ["histo", "hist", "histogram"];
        const WIN_VARIATIONS = ["w", "win"];
        const NOBS_VARIATIONS = ["n", "nobs", "knobs"];
        const FOK_VARIATIONS = ["fok", "four", "foak"];
        const FLUSH_VARIATIONS = ["f", "fl", "flush"];
        const SUPER_FLUSH_VARIATIONS = ["sf", "super", "superflush", "super flush"];
        const END_SESSION_VARIATIONS = ["end", "done", "exit", "fin", "quit"];
        const NUMBERS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];


        // GLOBAL VARIABLES (gasp) ---------------------------
        let usingBlankSaveData = false;  // flips to true if blank save data file is found
        let userWantsToCorrectRound = false;  	   // flag used to trigger the correction mechanism
        let userWantsToCorrect1stCribCut = false;
        let lastCutCardIndex = -1;  	// used as part of the correction mechanism. Needed because of where 
                                        // the backup snapshot is taken. We need to correct the crib cut data
                                        // for the cribber using this (we -1 for this cut in the cribber's data)
        let previousInvalidInput = "";
        let previousInvalidInputFix = -1;

        let molly = new Player("Molly", "    Molly");
        let johnny = new Player("Johnny", "   Johnny");
        let players = [molly, johnny]; // BLAH: is this still used?
        let mollyBackup = new Player("", "");
        let johnnyBackup = new Player("", "");
        let playerBackups = [mollyBackup, johnnyBackup]; // BLAH: is this still used?

        let cribber = null;  // these were all Player* pointers in C
        let nonCribber = null;   
        let cribberBackup = null;
        let nonCribberBackup = null;
        let playerWhoHadFirstCrib = null;
        let winner = null;


        async function main() {

            let userInput;  // string

            loadATDataFromFile(); // load the players' all-time data
            printCentered(3, "* * * *  MOLLY & JOHNNY'S CRIBULATOR!!!  * * * *", 2);

            do {  // game loop ------------------------------
                if (!userWantsToCorrect1stCribCut)
                    print("New game!\n\n");

                if (await cutToSeeWhoGetsFirstCrib() == USER_WANTS_TO_END_SESSION)
                    break;
                playerWhoHadFirstCrib = cribber; 
                cribber.numFirstCribsToday++;
                cribber.numFirstCribsAT++;

                if (userWantsToCorrectRound)
                    restoreBackupOfVariables();
                
                do {  // hand loop -----------------------			
                    if (await cutTheStarterCard() == DEALER_WINS_FROM_NIBS) {
                        winner = await winHandler("nibs win", 0);
                        if (winner != null)  break;  // we have a winner
                    }
                    if (userWantsToCorrectRound) {
                        if (userWantsToCorrect1stCribDraw()) {
                            cribber.numFirstCribsToday--;
                            cribber.numFirstCribsAT--;
                            break;
                        }
                        restoreBackupOfVariables();
                        continue;
                    }

                    backupVariables();
                    //backupWasJustRestored = false;  <-- was using this to be efficient, but it was getting tricky so fck it
                    incrementHandCounters();

                    do {
                        print(nonCribber.indtAdjstdName + "'s hand:  ");
                        userInput = await getlineMine();
                    } while(handleStatsRequests(userInput) );
                    if (handleInputFlags(userInput, nonCribber) == SOMEONE_HAS_WON) {
                        if (!srch(userInput, NUMBERS))
                            winner = await winHandler("someone won via pegging", 0);
                        else 
                            winner = await winHandler("nonCribber wins via hand", await pointValueOf(userInput));
                        if (winner != null)  break;
                    }
                    if (userWantsToCorrectRound) {
                        restoreBackupOfVariables();
                        continue;
                    }
                    let ptValue = await pointValueOf(userInput);
                    nonCribber.histoHandPtsAT[ptValue]++;
                    nonCribber.histoHandPtsToday[ptValue]++;
                    nonCribber.handPtsThisGame += ptValue;

                    do {
                        print(cribber.indtAdjstdName + "'s hand:  ");
                        userInput = await getlineMine();
                    } while(handleStatsRequests(userInput) );
                    if (handleInputFlags(userInput, cribber) == CRIBBER_WINS) {
                        winner = await winHandler("cribber wins via hand", await pointValueOf(userInput));
                        if (winner != null)  break;
                    }
                    if (userWantsToCorrectRound) {
                        restoreBackupOfVariables();
                        continue;
                    }
                    ptValue = await pointValueOf(userInput);
                    cribber.histoHandPtsAT[ptValue]++;
                    cribber.histoHandPtsToday[ptValue]++;
                    cribber.handPtsThisGame += ptValue;

                    do {
                        print(cribber.indtAdjstdName + "'s crib:  ");
                        userInput = await getlineMine();
                    } while(handleStatsRequests(userInput) );
                    if (handleInputFlags(userInput, cribber) == CRIBBER_WINS) {
                        winner = await winHandler("cribber wins via crib", await pointValueOf(userInput));
                        if (winner != null)  break;
                    }
                    if (userWantsToCorrectRound) {
                        restoreBackupOfVariables();
                        continue;
                    }
                    ptValue = await pointValueOf(userInput);
                    cribber.histoCribPtsAT[ptValue]++;
                    cribber.histoCribPtsToday[ptValue]++;
                    cribber.cribPtsThisGame += ptValue;
                    
                    printEndOfHandStuff(); 
                    swapCribbers();
                    print("\n\n" + cribber.name + "'s crib\n");
                    
                } while(!srch(userInput, END_SESSION_VARIATIONS));

                if (!userWantsToCorrect1stCribCut) {  // skip if user is correcting the draw to see who gets game's 1st crib
                    updatePlayerDataAfterGame();
                    printEndOfGameStuff();
                    resetThisGameDataForPlayers();
                }

            } while(!srch(userInput, END_SESSION_VARIATIONS) );

            performEndOfSessionTasks();
        }



        // ----- FUNCTIONS ----------------------------
        function float2digs(nbr) { // float (float)  (This is unique to this JS version)
            return nbr.toFixed(2);
        }


        function userWantsToEndSession(input) { // bool (string)
            return srch(input, END_SESSION_VARIATIONS);
        }


        async function cutToSeeWhoGetsFirstCrib() {  // bool ()
            // returns false if user indicates they want to quit playing; else true
            let mollyCut;  // string
            let johnnyCut;  // string
            let mollyCardIndex;  // int
            let johnnyCardIndex;  // int

            do {
                print(" Molly draws a  ");
                mollyCut = await getlineMine();
            } while(handleStatsRequests(mollyCut) );
            if (userWantsToEndSession(mollyCut))
                return false;  // quit for today
            if (userWantsToCorrectRound) 
                return true;  // will have been flipped in getlineMine() via the user's input if true
            mollyCardIndex = await cardIndexOf(mollyCut);

            do {
                print("Johnny draws a  ");
                johnnyCut = await getlineMine();
            } while(handleStatsRequests(johnnyCut) );
            if (userWantsToEndSession(johnnyCut))
                return false;  // quit for today
            if (userWantsToCorrectRound) {
                userWantsToCorrectRound = false;  // if correction input is entered here, assume user just wants to correct the cut input
                return await cutToSeeWhoGetsFirstCrib(); // just start again if user wants to correct at this step
            }
            johnnyCardIndex = await cardIndexOf(johnnyCut);

            molly.histoCutsForFirstCribAT[mollyCardIndex]++;
            molly.cutsForFirstCribToday.push(cardStringForIndex(mollyCardIndex));
            johnny.histoCutsForFirstCribAT[johnnyCardIndex]++;
            johnny.cutsForFirstCribToday.push(cardStringForIndex(johnnyCardIndex));
            if (mollyCardIndex < johnnyCardIndex)
                assignCribTo('M');
            else  
                assignCribTo('J');
            print("\n" + cribber.name + " gets first crib!\n");
            return true;  // yes, we cut and are going to play a game
        }


        function assignCribTo(cribberInitial) {  // void (char)
            // BLAH these are using hard-coded values... at least use constants at the top of the program
            if (cribberInitial == 'm' || cribberInitial == 'M') {
                cribber = molly;
                nonCribber = johnny;
            }
            else if (cribberInitial == 'j' || cribberInitial == 'J') {
                cribber = johnny;
                nonCribber = molly;
            }
            else {
                print("\n\nIncorrect cribberInitial passed to \"assignCribTo\" function: \'" +
                        cribberInitial + "\'\nprogram closing...\n\n");
                exitProgram();
            }
        }


        function swapCribbers() { // void ()
            const temp = cribber;
            cribber = nonCribber;
            nonCribber = temp;
        }


        function incrementHandCounters() {  // void()
        // note: this will track unused hands and cribs, because of where it gets called
            cribber.numHandsThisGame++;
            cribber.numHandsToday++;
            cribber.numHandsAT++;
            cribber.numCribsThisGame++;
            cribber.numCribsToday++;
            cribber.numCribsAT++;
            nonCribber.numHandsThisGame++;
            nonCribber.numHandsToday++;
            nonCribber.numHandsAT++;
        }


        async function cutTheStarterCard() {  // bool ()
        // returns true if the cut results in the cribber winning; false otherwise
        // BLAH: refactor the if statement by using a to_upper() function (make one)
            let theCut;  // string - aka the "starter card" that is cut
            let cutCardIndex;  // int
            do {
                print("         the cut:  ");
                theCut = await getlineMine();
            } while(handleStatsRequests(theCut) );
            if (userWantsToCorrectRound)
                return false;

            cutCardIndex = await cardIndexOf(theCut);
            cribber.histoCutsForMyCribToday[cutCardIndex]++;
            cribber.histoCutsForMyCribAT[cutCardIndex]++;
            lastCutCardIndex = cutCardIndex;
            if ( srch(theCut, "j") || srch(theCut, "J") || 
                srch(theCut, "w") || srch(theCut, "W")    ) {  // nibs
                cribber.numNibsThisGame++;
                if (srch(theCut, "w") || srch(theCut, "W"))  // nibs for the win!
                    return true;
            }
            return false;
        }


        function handleInputFlags(userInput, player) {  // bool (string, Player*)
        // returns true if the flags indicate a win; false otherwise
        // Be careful about the order you check these, especially the ones with single letter variations...

            if (srch(userInput, FOK_VARIATIONS) ){
                player.FOKsToday++;
                player.FOKsAT++;
            } else if (srch(userInput, SUPER_FLUSH_VARIATIONS) ){
                player.superFlushesToday++;
                player.superFlushesAT++;
            } else if (srch(userInput, FLUSH_VARIATIONS) && !srch(userInput, FOK_VARIATIONS) ){ // don't let 'fok' also count as a flush
                player.flushesToday++;
                player.flushesAT++;
            }

            if (srch(userInput, NOBS_VARIATIONS) ){
                player.nobsToday++;
                player.nobsAT++;
            }

            if (srch(userInput, WIN_VARIATIONS) )
                return true;  // someone has won

            return false; // no win indicated
        }




// CONTINUE HERE: move all operands to the end of previous line instead of start of next line... doesn't work
        async function winHandler(winCondition, ptsInWinningInput) {  // Player* (string, int)
        // Calculates all the necessary crap when user indicates a win
        // returns a pointer to the winning player
        // returns a null pointer in the event user wants to make a correction to the hand
            let userInput;  // string - just going to use this for most of the input and reuse it,
                            // so I'll have mind the order in which I calculate stuff...

            if (srch(winCondition, "nibs win") ){
                printCentered(1, "~ ~ ~  " + cribber.name + " wins!  ~ ~ ~", 3);
                print("How many points were needed?  ");
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;  // user wants to make a correction; no winner rn
                cribber.unusedPtsThisGame[NIBS] += (2 - mystoi(userInput) );
                cribber.unusedPtsToday[NIBS] += cribber.unusedPtsThisGame[NIBS];
                cribber.unusedPtsAT[NIBS] += cribber.unusedPtsThisGame[NIBS];

                // calc winner's pegged points for this game
                cribber.peggedPtsThisGame = 121 - mystoi(userInput)
                                                - cribber.handPtsThisGame 
                                                - cribber.cribPtsThisGame 
                                                - ((cribber.numNibsThisGame - 1) * 2); // -1 because we've already incr. numNibsThisGame in cut function								 
                cribber.peggedPtsToday += cribber.peggedPtsThisGame;
                cribber.peggedPtsAt += cribber.peggedPtsThisGame;

                // record loser's position
                print(" " + nonCribber.indtAdjstdName + "'s pos:  ");  // nonCribber lost
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                nonCribber.losingPositionToday += mystoi(userInput);

                // use that to calc the winner's winning margin
                cribber.winMarginsToday.push(121 - mystoi(userInput));
                cribber.histoWinMarginsAT[121 - mystoi(userInput)]++;

                // and now calc loser's pegged points for this game
                nonCribber.peggedPtsThisGame = mystoi(userInput)
                                                - nonCribber.handPtsThisGame 
                                                - nonCribber.cribPtsThisGame 
                                                - (nonCribber.numNibsThisGame * 2);								 
                nonCribber.peggedPtsToday += nonCribber.peggedPtsThisGame;
                nonCribber.peggedPtsAt += nonCribber.peggedPtsThisGame;

                // record the other uncounted and excess points...
                // Hmmm, have to make an important decision here:
                // Do we count the unused hands and cribs toward their respective stats?
                // > Yes, I think we do. That way we can calc. averages properly.
                // We'll also keep track of the unused pts so we can subtract and calc
                // the "strict points" for a hand when desired
                print(nonCribber.indtAdjstdName + "'s hand:  ");
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                handleInputFlags(userInput, nonCribber);
                nonCribber.handPtsThisGame += mystoi(userInput);
                nonCribber.histoHandPtsToday[mystoi(userInput)]++;
                nonCribber.histoHandPtsAT[mystoi(userInput)]++;
                nonCribber.unusedPtsThisGame[HAND] += mystoi(userInput);
                nonCribber.unusedPtsToday[HAND] += mystoi(userInput);
                nonCribber.unusedPtsAT[HAND] += mystoi(userInput);

                print(cribber.indtAdjstdName + "'s hand:  ");
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                handleInputFlags(userInput, cribber);
                cribber.handPtsThisGame += mystoi(userInput);
                cribber.histoHandPtsToday[mystoi(userInput)]++;
                cribber.histoHandPtsAT[mystoi(userInput)]++;
                cribber.unusedPtsThisGame[HAND] += mystoi(userInput);
                cribber.unusedPtsToday[HAND] += mystoi(userInput);
                cribber.unusedPtsAT[HAND] += mystoi(userInput);

                print(cribber.indtAdjstdName + "'s crib:  ");
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                handleInputFlags(userInput, cribber);
                cribber.cribPtsThisGame += mystoi(userInput);
                cribber.histoCribPtsToday[mystoi(userInput)]++;
                cribber.histoCribPtsAT[mystoi(userInput)]++;
                cribber.unusedPtsThisGame[CRIB] += mystoi(userInput);
                cribber.unusedPtsToday[CRIB] += mystoi(userInput);
                cribber.unusedPtsAT[CRIB] += mystoi(userInput);

                return cribber;
            }


            else if (srch(winCondition, "someone won via pegging") ){  
            // REFACTOR: there is SO much duplication of the above, below; there has to be a better way of doing this
            // can probably use *winner and *loser Player pointers to cut down on the code
                print("Who won?  ");
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                print("How many points were needed?  ");
                let ptsNeeded = await getlineMine();  if (userWantsToCorrectRound)  return null;
                print("How many points would have been pegged if there were space?  ");
                let peggedHypothetically = await getlineMine();  if (userWantsToCorrectRound)  return null;

                if (cribber.name[0].toUpperCase() == userInput[0].toUpperCase()) {  // cribber won
                    cribber.unusedPtsThisGame[PEGGED] += (mystoi(peggedHypothetically) - mystoi(ptsNeeded) );
                    cribber.unusedPtsToday[PEGGED] += cribber.unusedPtsThisGame[PEGGED];
                    cribber.unusedPtsAT[PEGGED] += cribber.unusedPtsThisGame[PEGGED];

                    // calc winner's pegged points for this game
                    cribber.peggedPtsThisGame = 121 - cribber.handPtsThisGame 
                                                    - cribber.cribPtsThisGame 
                                                    - (cribber.numNibsThisGame * 2) 
                                                    + cribber.unusedPtsThisGame[PEGGED];  // have to include these to be consistent with the other point variables (they all store the macrogame data, not strict game data)							 
                    cribber.peggedPtsToday += cribber.peggedPtsThisGame;
                    cribber.peggedPtsAt += cribber.peggedPtsThisGame;

                    // record loser's position
                    print(" " + nonCribber.indtAdjstdName + "'s pos:  ");  // nonCribber lost
                    userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                    nonCribber.losingPositionToday += mystoi(userInput);

                    // use that to calc the winner's winning margin
                    cribber.winMarginsToday.push(121 - mystoi(userInput));
                    cribber.histoWinMarginsAT[121 - mystoi(userInput)]++;

                    // and now calc loser's pegged points for this game
                    nonCribber.peggedPtsThisGame = mystoi(userInput)
                                                    - nonCribber.handPtsThisGame 
                                                    - nonCribber.cribPtsThisGame 
                                                    - (nonCribber.numNibsThisGame * 2);								 
                    nonCribber.peggedPtsToday += nonCribber.peggedPtsThisGame;
                    nonCribber.peggedPtsAt += nonCribber.peggedPtsThisGame;

                    // record the other uncounted and excess points...
                    print(nonCribber.indtAdjstdName + "'s hand:  ");
                    userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                    handleInputFlags(userInput, nonCribber);
                    nonCribber.handPtsThisGame += mystoi(userInput);
                    nonCribber.histoHandPtsToday[mystoi(userInput)]++;
                    nonCribber.histoHandPtsAT[mystoi(userInput)]++;
                    nonCribber.unusedPtsThisGame[HAND] += mystoi(userInput);
                    nonCribber.unusedPtsToday[HAND] += mystoi(userInput);
                    nonCribber.unusedPtsAT[HAND] += mystoi(userInput);
                    
                    print(cribber.indtAdjstdName + "'s hand:  ");
                    userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                    handleInputFlags(userInput, cribber);
                    cribber.handPtsThisGame += mystoi(userInput);			
                    cribber.histoHandPtsToday[mystoi(userInput)]++;
                    cribber.histoHandPtsAT[mystoi(userInput)]++;
                    cribber.unusedPtsThisGame[HAND] += mystoi(userInput);
                    cribber.unusedPtsToday[HAND] += mystoi(userInput);
                    cribber.unusedPtsAT[HAND] += mystoi(userInput);

                    print(cribber.indtAdjstdName + "'s crib:  ");
                    userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                    handleInputFlags(userInput, cribber);
                    cribber.cribPtsThisGame += mystoi(userInput);
                    cribber.histoCribPtsToday[mystoi(userInput)]++;
                    cribber.histoCribPtsAT[mystoi(userInput)]++;
                    cribber.unusedPtsThisGame[CRIB] += mystoi(userInput);
                    cribber.unusedPtsToday[CRIB] += mystoi(userInput);
                    cribber.unusedPtsAT[CRIB] += mystoi(userInput);

                    return cribber;
                }
                else {  // nonCribber won
                    nonCribber.unusedPtsThisGame[PEGGED] += (mystoi(peggedHypothetically) - mystoi(ptsNeeded) );
                    nonCribber.unusedPtsToday[PEGGED] += nonCribber.unusedPtsThisGame[PEGGED];
                    nonCribber.unusedPtsAT[PEGGED] += nonCribber.unusedPtsThisGame[PEGGED];

                    // calc winner's pegged points for this game
                    nonCribber.peggedPtsThisGame = 121 - nonCribber.handPtsThisGame 
                                                        - nonCribber.cribPtsThisGame 
                                                        - (nonCribber.numNibsThisGame * 2)
                                                        + nonCribber.unusedPtsThisGame[PEGGED]; // (for same reason given above in 'if' case)					 
                    nonCribber.peggedPtsToday += nonCribber.peggedPtsThisGame;
                    nonCribber.peggedPtsAt += nonCribber.peggedPtsThisGame;

                    // record loser's position
                    print(" " + cribber.indtAdjstdName + "'s pos:  ");  // cribber lost
                    userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                    cribber.losingPositionToday += mystoi(userInput);

                    // use that to calc the winner's winning margin
                    nonCribber.winMarginsToday.push(121 - mystoi(userInput));
                    nonCribber.histoWinMarginsAT[121 - mystoi(userInput)]++;

                    // and now calc loser's pegged points for this game
                    cribber.peggedPtsThisGame = mystoi(userInput)
                                                    - cribber.handPtsThisGame 
                                                    - cribber.cribPtsThisGame 
                                                    - (cribber.numNibsThisGame * 2);								 
                    cribber.peggedPtsToday += cribber.peggedPtsThisGame;
                    cribber.peggedPtsAt += cribber.peggedPtsThisGame;

                    // record the other uncounted and excess points...
                    print(nonCribber.indtAdjstdName + "'s hand:  ");
                    userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                    handleInputFlags(userInput, nonCribber);
                    nonCribber.handPtsThisGame += mystoi(userInput);
                    nonCribber.histoHandPtsToday[mystoi(userInput)]++;
                    nonCribber.histoHandPtsAT[mystoi(userInput)]++;
                    nonCribber.unusedPtsThisGame[HAND] += mystoi(userInput);
                    nonCribber.unusedPtsToday[HAND] += mystoi(userInput);
                    nonCribber.unusedPtsAT[HAND] += mystoi(userInput);

                    print(cribber.indtAdjstdName + "'s hand:  ");
                    userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                    handleInputFlags(userInput, cribber);
                    cribber.handPtsThisGame += mystoi(userInput);
                    cribber.histoHandPtsToday[mystoi(userInput)]++;
                    cribber.histoHandPtsAT[mystoi(userInput)]++;
                    cribber.unusedPtsThisGame[HAND] += mystoi(userInput);
                    cribber.unusedPtsToday[HAND] += mystoi(userInput);
                    cribber.unusedPtsAT[HAND] += mystoi(userInput);
                    
                    print(cribber.indtAdjstdName + "'s crib:  ");
                    userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                    handleInputFlags(userInput, cribber);
                    cribber.cribPtsThisGame += mystoi(userInput);
                    cribber.histoCribPtsToday[mystoi(userInput)]++;
                    cribber.histoCribPtsAT[mystoi(userInput)]++;
                    cribber.unusedPtsThisGame[CRIB] += mystoi(userInput);
                    cribber.unusedPtsToday[CRIB] += mystoi(userInput);
                    cribber.unusedPtsAT[CRIB] += mystoi(userInput);

                    return nonCribber;
                }
            } // someone won via pegging


            else if (srch(winCondition, "nonCribber wins via hand") ){
                printCentered(1, "~ ~ ~  " + nonCribber.name + " wins!  ~ ~ ~", 3);
                print("How many points were needed?  ");
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                nonCribber.unusedPtsThisGame[HAND] += (ptsInWinningInput - mystoi(userInput) );
                nonCribber.unusedPtsToday[HAND] += nonCribber.unusedPtsThisGame[HAND];
                nonCribber.unusedPtsAT[HAND] += nonCribber.unusedPtsThisGame[HAND];

                // calc winner's pegged points for this game
                nonCribber.peggedPtsThisGame = 121 - mystoi(userInput)
                                                    - nonCribber.handPtsThisGame 
                                                    - nonCribber.cribPtsThisGame 
                                                    - (nonCribber.numNibsThisGame * 2);							 
                nonCribber.peggedPtsToday += nonCribber.peggedPtsThisGame;
                nonCribber.peggedPtsAt += nonCribber.peggedPtsThisGame;

                // record loser's position
                print(" " + cribber.indtAdjstdName + "'s pos:  ");  // cribber lost
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                cribber.losingPositionToday += mystoi(userInput);

                // use that to calc the winner's winning margin
                nonCribber.winMarginsToday.push(121 - mystoi(userInput));
                nonCribber.histoWinMarginsAT[121 - mystoi(userInput)]++;

                // and now calc loser's pegged points for this game
                cribber.peggedPtsThisGame = mystoi(userInput)
                                                - cribber.handPtsThisGame 
                                                - cribber.cribPtsThisGame 
                                                - (cribber.numNibsThisGame * 2);								 
                cribber.peggedPtsToday += cribber.peggedPtsThisGame;
                cribber.peggedPtsAt += cribber.peggedPtsThisGame;

                // record the other uncounted and excess points...
                nonCribber.handPtsThisGame += ptsInWinningInput;
                nonCribber.histoHandPtsToday[ptsInWinningInput]++;
                nonCribber.histoHandPtsAT[ptsInWinningInput]++;

                print(cribber.indtAdjstdName + "'s hand:  ");
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                handleInputFlags(userInput, cribber);
                cribber.handPtsThisGame += mystoi(userInput);
                cribber.histoHandPtsToday[mystoi(userInput)]++;
                cribber.histoHandPtsAT[mystoi(userInput)]++;
                cribber.unusedPtsThisGame[HAND] += mystoi(userInput);
                cribber.unusedPtsToday[HAND] += mystoi(userInput);
                cribber.unusedPtsAT[HAND] += mystoi(userInput);
                
                print(cribber.indtAdjstdName + "'s crib:  ");
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                handleInputFlags(userInput, cribber);
                cribber.cribPtsThisGame += mystoi(userInput);
                cribber.histoCribPtsToday[mystoi(userInput)]++;
                cribber.histoCribPtsAT[mystoi(userInput)]++;
                cribber.unusedPtsThisGame[CRIB] += mystoi(userInput);
                cribber.unusedPtsToday[CRIB] += mystoi(userInput);
                cribber.unusedPtsAT[CRIB] += mystoi(userInput);

                return nonCribber;
            }


            else if (srch(winCondition, "cribber wins via hand") ){
                printCentered(1, "~ ~ ~  " + cribber.name + " wins!  ~ ~ ~", 3);
                print("How many points were needed?  ");
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                cribber.unusedPtsThisGame[HAND] += (ptsInWinningInput - mystoi(userInput) );
                cribber.unusedPtsToday[HAND] += cribber.unusedPtsThisGame[HAND];
                cribber.unusedPtsAT[HAND] += cribber.unusedPtsThisGame[HAND];

                // calc winner's pegged points for this game
                cribber.peggedPtsThisGame = 121 - mystoi(userInput)
                                                - cribber.handPtsThisGame 
                                                - cribber.cribPtsThisGame 
                                                - (cribber.numNibsThisGame * 2);							 
                cribber.peggedPtsToday += cribber.peggedPtsThisGame;
                cribber.peggedPtsAt += cribber.peggedPtsThisGame;

                // record loser's position
                print(" " + nonCribber.indtAdjstdName + "'s pos:  ");  // nonCribber lost
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                nonCribber.losingPositionToday += mystoi(userInput);

                // use that to calc the winner's winning margin
                cribber.winMarginsToday.push(121 - mystoi(userInput));
                cribber.histoWinMarginsAT[121 - mystoi(userInput)]++;

                // and now calc loser's pegged points for this game
                nonCribber.peggedPtsThisGame = mystoi(userInput)
                                                - nonCribber.handPtsThisGame 
                                                - nonCribber.cribPtsThisGame 
                                                - (nonCribber.numNibsThisGame * 2);								 
                nonCribber.peggedPtsToday += nonCribber.peggedPtsThisGame;
                nonCribber.peggedPtsAt += nonCribber.peggedPtsThisGame;

                // record the other uncounted and excess points...
                cribber.handPtsThisGame += ptsInWinningInput;
                cribber.histoHandPtsToday[ptsInWinningInput]++;
                cribber.histoHandPtsAT[ptsInWinningInput]++;
                
                print(cribber.indtAdjstdName + "'s crib:  ");
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                handleInputFlags(userInput, cribber);
                cribber.cribPtsThisGame += mystoi(userInput);
                cribber.histoCribPtsToday[mystoi(userInput)]++;
                cribber.histoCribPtsAT[mystoi(userInput)]++;
                cribber.unusedPtsThisGame[CRIB] += mystoi(userInput);
                cribber.unusedPtsToday[CRIB] += mystoi(userInput);
                cribber.unusedPtsAT[CRIB] += mystoi(userInput);

                return cribber;
            }


            else if (srch(winCondition, "cribber wins via crib") ){
                printCentered(1, "~ ~ ~  " + cribber.name + " wins!  ~ ~ ~", 3);
                print("How many points were needed?  ");
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                cribber.unusedPtsThisGame[CRIB] += (ptsInWinningInput - mystoi(userInput) );
                cribber.unusedPtsToday[CRIB] += cribber.unusedPtsThisGame[CRIB];
                cribber.unusedPtsAT[CRIB] += cribber.unusedPtsThisGame[CRIB];

                // calc winner's pegged points for this game
                cribber.peggedPtsThisGame = 121 - mystoi(userInput)
                                                - cribber.handPtsThisGame 
                                                - cribber.cribPtsThisGame
                                                - (cribber.numNibsThisGame * 2);							 
                cribber.peggedPtsToday += cribber.peggedPtsThisGame;
                cribber.peggedPtsAt += cribber.peggedPtsThisGame;

                // record loser's position
                print(" " + nonCribber.indtAdjstdName + "'s pos:  ");  // nonCribber lost
                userInput = await getlineMine();  if (userWantsToCorrectRound)  return null;
                nonCribber.losingPositionToday += mystoi(userInput);

                // use that to calc the winner's winning margin
                cribber.winMarginsToday.push(121 - mystoi(userInput));
                cribber.histoWinMarginsAT[121 - mystoi(userInput)]++;  // check the indexing on this... hmmm.

                // and now calc loser's pegged points for this game
                nonCribber.peggedPtsThisGame = mystoi(userInput)
                                                - nonCribber.handPtsThisGame 
                                                - nonCribber.cribPtsThisGame 
                                                - (nonCribber.numNibsThisGame * 2);								 
                nonCribber.peggedPtsToday += nonCribber.peggedPtsThisGame;
                nonCribber.peggedPtsAt += nonCribber.peggedPtsThisGame;

                // record the other uncounted and excess points...
                cribber.cribPtsThisGame += ptsInWinningInput;
                cribber.histoCribPtsToday[ptsInWinningInput]++;
                cribber.histoCribPtsAT[ptsInWinningInput]++;

                return cribber;
            }

            else {
                print("\n\n*** Error: 'else' statement reached in winHandler() ***\n");
                print("    program closing...\n\n\n");
                exitProgram();
            }
        }


        function sumOfHistogram(histo) {  // int (vector<int>)
            let sum = 0;  // int
            for (let i = 0; i < histo.length; i++)
                sum += i * histo[i];
            return sum; 
        }


        function printEndOfHandStuff() {  // void ()
        // want it to be somethng like this for ex: 
        // 4.63 this game    5.46 today (33)    4.41 all-time (2034)
            print("\n           crib avg:       ");
            print(((players[0].cribPtsThisGame + players[1].cribPtsThisGame) * 1.0) / 
                  (players[0].numHandsThisGame * 1.0) +
                  " this game     " +
                  combinedCribAverage("today") + " today (" + players[0].numHandsToday + ")     " +
                  combinedCribAverage("all-time") + " ever (" +
                  (USE_LEGACY_DATA ? players[0].numHandsAT + players[0].legacyNumHands : 
                                     players[0].numHandsAT) + ")");
        }


        function updatePlayerDataAfterGame() {  // void()
            let macrogamePtsThisGame;  // have to update this at game's end and not every hand because we need
                                       // to have pegged points calculated first, and that only happens at game's end
            for (const p of players) {
                macrogamePtsThisGame = p.handPtsThisGame +
                                       p.cribPtsThisGame +
                                       (p.numNibsThisGame * 2) +
                                       p.peggedPtsThisGame;
                p.macrogamePtsToday += macrogamePtsThisGame;
                p.macrogamePtsAT += macrogamePtsThisGame;

                p.gamesPlayedToday++;
                p.gamesPlayedAT++;
            }
            winner.winsToday++;
            winner.winsAT++;
            if (winner.name == playerWhoHadFirstCrib.name) {
                winner.numFirstCribsWonToday++;
                winner.numFirstCribsWonAT++;
            }
        }


        function printEndOfGameStuff() {  // void (_
        // calculate and display the stats you want to at the end of a game:
            printCentered(1, "Congratulations " + winner.name + "!", 1);
            let winWord;
            if (winner.winsToday == 1)
                winWord = "1st";
            else if (winner.winsToday == 2)
                winWord = "2nd";
            else if (winner.winsToday == 3)
                winWord = "3rd";
            else 
                winWord = "" + winner.winsToday + "th";
            printCentered(0, "That's your " + winWord + " win today!", 3);

            printCentered(0, "Game " + players[0].gamesPlayedToday + " stats:", 2);
            // points breakdown for the winner
            printPointsBreakdownForPlayerThisGame(winner);
            print("\n");
            // points breakdown for the loser
            // will do it, but problem:  loser's unused pts have been added to their 'ThisGame' variables already,
            // ... so the numbers won't be correct for them as it stands... how to fix this?
            printPointsBreakdownForPlayerThisGame(determineLoser());
            print("\n");

            // xxx pts (Leader) to yyy pts (Trailer) in today's macro-game thus far...  


            // any average/combined stats of interest?


            print("\n");
        }


        function printPointsBreakdownForPlayerThisGame(p) {  // void (Player*)
        // BLAH: use printf() for this to simplify the formatting
            //cout << setprecision(0) << fixed;
            const BD_INDENT = "                                    ";

            const strictHandPts = p.handPtsThisGame - p.unusedPtsThisGame[HAND];
            const strictCribPts = p.cribPtsThisGame - p.unusedPtsThisGame[CRIB];
            const strictNibsPts = (p.numNibsThisGame * 2) - p.unusedPtsThisGame[NIBS];
            const strictPeggedPts = p.peggedPtsThisGame - p.unusedPtsThisGame[PEGGED];
            const finPos = strictHandPts + strictCribPts + strictNibsPts + strictPeggedPts;

            const handPercent = (strictHandPts * 100.0) / (finPos * 1.0);
            const cribPercent = (strictCribPts * 100.0) / (finPos * 1.0);
            const nibsPercent = (strictNibsPts * 100.0) / (finPos * 1.0);
            const peggedPercent = (strictPeggedPts * 100.0) / (finPos * 1.0);

            print("           " +
                 ((finPos > 99) ? "" : " ") + p.indtAdjstdName + "'s " +
                 finPos + " pts:\n");

            print(BD_INDENT + strictHandPts + "  hands" +
                 ((handPercent > 9.5) ? ' '.repeat(5) : ' '.repeat(6)) +
                 handPercent + "%\n"); 

            print(BD_INDENT + ((strictCribPts >= 10) ? "" : " ") +
                 strictCribPts + "  cribs" +
                 ((cribPercent > 9.5) ? ' '.repeat(5) : ' '.repeat(6)) +
                 cribPercent + "%\n");
                
            if (strictNibsPts > 0)
                print(BD_INDENT + " " + strictNibsPts + "  nibs       " +
                     nibsPercent + "%\n");

            print(BD_INDENT + ((strictPeggedPts >= 10) ? "" : " ") +
                 strictPeggedPts + "  pegging" +
                 ((peggedPercent > 9.5) ? ' '.repeat(3) : ' '.repeat(4)) +
                 peggedPercent + "%\n");

            //cout << setprecision(2) << fixed; 
        }


        function resetThisGameDataForPlayers() {  // void ()
        // zeros all the 'ThisGame' data for each player; used before starting a new game, after finishing one.
        // Also updates each player's gamesPlayedAT and gamesPlayedToday attributes
            for (let p of players) {
                p.handPtsThisGame = 0;
                p.cribPtsThisGame = 0;
                p.numNibsThisGame = 0;
                p.peggedPtsThisGame = 0;
                p.unusedPtsThisGame = [0,0,0,0];
                p.numHandsThisGame = 0;
                p.numCribsThisGame = 0;
            }
        }


        function combinedCribAverage(timeframe) {  // float (string)
            if (timeframe == "today")
                return computeMeanFromHisto(combinedHistoFrom([players[0].histoCribPtsToday, players[1].histoCribPtsToday]));

            else if (timeframe == "all-time" && USE_LEGACY_DATA)
                return ( (sumOfHistogram(players[0].histoCribPtsAT) +
                          sumOfHistogram(players[1].histoCribPtsAT) +
                          players[0].legacyCribSum ) * 1.0) / 
                         ((players[0].numHandsAT + players[0].legacyNumHands) * 1.0);

            else if (timeframe == "all-time" && !USE_LEGACY_DATA)
                return computeMeanFromHisto(combinedHistoFrom([players[0].histoCribPtsAT, players[1].histoCribPtsAT]));

            else {
                print("\n\n\n*** Error: invalid timeframe specified for 'combinedCribAverage()' call ***\n");
                print("program closing...\n\n\n");
                exitProgram();
            }
        }


        function performEndOfSessionTasks() {  // void ()
        // handle stuff before exiting program
            for (const p of players) {
                p.numSessionsPlayedAT++;
            }

            printEndOfSessionStuff();
            saveATDataToFile();
        }


        function to_string(thing) {
            return "" + thing;
        }


        function printEndOfSessionStuff() {  // void ()
        // display the stats you want to at the end of the day's session:
            printCentered(2, "--  --  --  --  --  --  --  --  --  --  --  --  --  --", 3);

            // print win vs win results today
            if (players[0].winsToday >= players[1].winsToday) {
                printCentered(1, "Today's champion: " + 
                    ((players[0].winsToday == players[1].winsToday) ? "It's a tie" : players[0].name) + "!", 2);
                printCentered(0, to_string(players[0].winsToday) + " wins for " + players[0].name + "  vs  " +
                    to_string(players[1].winsToday) + " wins for " + players[1].name, 4);
            } else {
                printCentered(1, "Today's champion: " + players[1].name + "!", 2);
                printCentered(0, to_string(players[1].winsToday) + " wins for " + players[1].name + "  vs  " +
                    to_string(players[0].winsToday) + " wins for " + players[0].name, 4);
            }

            // print macrogame results today
            printCentered(0, "Today's MACRO-game:", 2);
            if (players[0].macrogamePtsToday >= players[1].macrogamePtsToday) {
                printCentered(0, players[0].name + " had " + to_string(players[0].macrogamePtsToday) + " pts  vs  " +
                    to_string(players[1].macrogamePtsToday) + " pts for " + players[1].name, 2);
                printCentered(0, "(" + to_string(players[0].macrogamePtsToday - players[1].macrogamePtsToday) + " pt gain for " + players[0].name + "!)", 4);
            }
            else {
                printCentered(0, players[1].name + " had " + to_string(players[1].macrogamePtsToday) + " pts  vs  " +
                    to_string(players[0].macrogamePtsToday) + " pts for " + players[0].name, 2);
                printCentered(0, "(" + to_string(players[1].macrogamePtsToday - players[0].macrogamePtsToday) + " pt gain for " + players[1].name + "!)", 4);
            }

            // print number of first crib wins
            printCentered(0, "Today", 2);
            printCentered(0, players[0].name + " won " + to_string(players[0].numFirstCribsWonToday) +
                " of their " + to_string(players[0].numFirstCribsToday) + " games where they had first crib.", 1);
            printCentered(0, players[1].name + " won " + to_string(players[1].numFirstCribsWonToday) +
                " of their " + to_string(players[1].numFirstCribsToday) + " games where they had first crib.", 2);

            printCentered(0, "All-time", 2);
            printCentered(0, players[0].name + " has won " + to_string(players[0].numFirstCribsWonAT) +
                " of their " + to_string(players[0].numFirstCribsAT) + " games where they had first crib.", 1);
            printCentered(0, players[1].name + " has won " + to_string(players[1].numFirstCribsWonAT) +
                " of their " + to_string(players[1].numFirstCribsAT) + " games where they had first crib all-time.", 4);

            // print macrogame results AT
            printCentered(0, "All-time MACRO-game (for 2023):", 2);
            if (players[0].macrogamePtsAT >= players[1].macrogamePtsAT) {
                printCentered(0, players[0].name + ": " + to_string(players[0].macrogamePtsAT) + " pts  vs  " +
                    to_string(players[1].macrogamePtsAT) + " pts for " + players[1].name, 2);
                printCentered(0, "(" + to_string(players[0].macrogamePtsAT - players[1].macrogamePtsAT) + " pt lead)", 4);
                
            }
            else {
                printCentered(0, players[1].name + ": " + to_string(players[1].macrogamePtsAT) + " pts  vs  " +
                    to_string(players[0].macrogamePtsAT) + " pts for " + players[0].name, 2);
                printCentered(0, "(" + to_string(players[1].macrogamePtsAT - players[0].macrogamePtsAT) + " pt lead)", 4);
            }


            // print AT win vs win
            let allTimeWinsP0 = players[0].winsAT;  // int
            let allTimeWinsP1 = players[1].winsAT;  // int
            if (USE_LEGACY_DATA) {
                allTimeWinsP0 += players[0].legacyWins;
                allTimeWinsP1 += players[1].legacyWins;
            }
            let optionalLegacyLabel = (USE_LEGACY_DATA ? " (since Jan 1 2022): " : ": ");  // string
            printCentered(0, "All-time wins" + optionalLegacyLabel, 2);
            if (allTimeWinsP0 >= allTimeWinsP1)
                printCentered(0, players[0].name + " has " + to_string(allTimeWinsP0) + " wins  vs  " +
                    to_string(allTimeWinsP1) + " wins for " + players[1].name, 4);
            else	
                printCentered(0, players[1].name + " has " + to_string(allTimeWinsP1) + " wins  vs  " +
                    to_string(allTimeWinsP0) + " wins for " + players[0].name, 4);

            // print crib averages
            const todayCribAvg = float2digs(combinedCribAverage("today"));
            const alltimeCribAvg = float2digs(combinedCribAverage("all-time"));
        
            printCentered(0, "Today's crib avg:  " + todayCribAvg + " pts  (" + 
                to_string(players[0].numHandsToday) + " hands)", 2); 
            printCentered(0, "All-time crib avg:  " + alltimeCribAvg + " pts  (" +
                (USE_LEGACY_DATA ? to_string(players[0].numHandsAT + players[0].legacyNumHands) :
                                   to_string(players[0].numHandsAT)) + " hands)", 4);
        }  // ^ * dont' think I need to use all those to_string() calls... at all, actually


        async function cardIndexOf(card) {  // int (string)
        // order is important. You'll want to srch for 10 before you srch for 1...

            // BLAH: also might want to check for erronious entries. What if 16 is entered, for example?
            // ...in this case, it will catch as a 1 and be entered as an Ace
            if (srch(card, "k"))  return 12;
            if (srch(card, "K"))  return 12;
            if (srch(card, "q"))  return 11;
            if (srch(card, "Q"))  return 11;
            if (srch(card, "j"))  return 10;  if (srch(card, "w"))  return 10;  // might happen
            if (srch(card, "J"))  return 10;  if (srch(card, "W"))  return 10;
            if (srch(card, "10")) return 9;
            if (srch(card, "9"))  return 8;
            if (srch(card, "8"))  return 7;
            if (srch(card, "7"))  return 6;
            if (srch(card, "6"))  return 5;
            if (srch(card, "5"))  return 4;
            if (srch(card, "4"))  return 3;
            if (srch(card, "3"))  return 2;
            if (srch(card, "2"))  return 1;
            if (srch(card, "1"))  return 0;
            if (srch(card, "a"))  return 0;
            if (srch(card, "A"))  return 0;

            printCentered(1, "Error: '" + card + "' is not a valid card", 2);
            print("What card did you mean?  ");
            let secondTry = await getlineMine();
            return await cardIndexOf(secondTry);
        }


        function cardStringForIndex(cardIndex) {  // string (int)
        // converts a card index to its string representation (goes in the opposite direction as cardIndexOf() )
            if (12 == cardIndex)  return "K";
            if (11 == cardIndex)  return "Q";
            if (10 == cardIndex)  return "J";
            if (9  == cardIndex)  return "10";
            if (8  == cardIndex)  return "9";
            if (7  == cardIndex)  return "8";
            if (6  == cardIndex)  return "7";
            if (5  == cardIndex)  return "6";
            if (4  == cardIndex)  return "5";
            if (3  == cardIndex)  return "4";
            if (2  == cardIndex)  return "3";
            if (1  == cardIndex)  return "2";
            if (0  == cardIndex)  return "A";

            printCentered(2, "Error: '" + cardIndex + "' is not a valid card index", 2);
            print("Exiting program...\n\n\n");
            exitProgram();
        }


        function exitProgram() {
            alert("exitProgram() function called. Should probably do something more than just alerting like this...");
        }


        async function pointValueOf(userInput) {  // int (string)
        // this is used to strip out any flags or excess present in userInput
        // order is important. You'll want to srch for 10 before you srch for 1...

            // BLAH: also might want to check for erronious entries. What if 19 is entered, for example?
            // ...in this case, it will catch as a 1 and be entered as an Ace, which is not what we want
            if (srch(userInput, "29")) return 29;
            if (srch(userInput, "28")) return 28;
            if (srch(userInput, "24")) return 24;
            if (srch(userInput, "23")) return 23;
            if (srch(userInput, "22")) return 22;
            if (srch(userInput, "21")) return 21;
            if (srch(userInput, "20")) return 20;
            if (srch(userInput, "18")) return 18;
            if (srch(userInput, "17")) return 17;
            if (srch(userInput, "16")) return 16;
            if (srch(userInput, "15")) return 15;
            if (srch(userInput, "14")) return 14;
            if (srch(userInput, "13")) return 13;
            if (srch(userInput, "12")) return 12;
            if (srch(userInput, "11")) return 11;	
            if (srch(userInput, "10")) return 10;
            if (srch(userInput, "9"))  return 9;
            if (srch(userInput, "8"))  return 8;
            if (srch(userInput, "7"))  return 7;
            if (srch(userInput, "6"))  return 6;
            if (srch(userInput, "5"))  return 5;
            if (srch(userInput, "4"))  return 4;
            if (srch(userInput, "3"))  return 3;
            if (srch(userInput, "2"))  return 2;
            if (srch(userInput, "1"))  return 1;
            if (srch(userInput, "0"))  return 0;

            printCentered(2, "Error: '" + userInput + "' is not a possible score", 2);
            print("  Re-enter value:  ");
            let secondTry = await getlineMine();
            return await pointValueOf(secondTry);
        }


        function printHistogram(input) {  // void (string)
        // // BLAH REFACTOR this: there's tons of repetition here. Could just declare a struct in 
        // // here and then pass a pointer to an instance of that in to a helper function that
        // // calculates all that stuff in each case.
        //     vector<string> mollyVariations      = {"mo", "M"};  // default is combined
        //     vector<string> johnnyVariations     = {"j", "J"};
        //     vector<string> handVariations       = {"han"};  // default is crib
        //     vector<string> todayVariations      = {"tod", "td", "TD", "Tod"};  // default is all-time
        //     vector<string> thickVariations      = {"th", "wi", "bi", "fat", "chub"};  // default is single bar width
        //     vector<string> totalsVariations     = {"am", "nu", "#", "tot"};  // default doesn't show totals
        //     vector<string> horizontalVariations = {"hor"};  // default is vertical presentation
        //     vector<int> histo;
        //     int domain = 0;  // highest point total achieved in the histogram(s) of interest
        //     int range = 0;  // highest value found throughout the domain of the histogram(s) of interest
        //     int extraIndent = 0;
        //     bool handHisto = srch(input, handVariations);
        //     bool forToday = srch(input, todayVariations);
        //     bool showMolly = srch(input, mollyVariations);
        //     bool showJohnny = srch(input, johnnyVariations);
        //     bool presentHorizontally = srch(input, horizontalVariations);
        //     bool useThickBars = srch(input, thickVariations);
        //     bool showAmounts = srch(input, totalsVariations);
        //     string barChar = !presentHorizontally ? "": "";// useThickBars ? "": "";
        //     string headDec = "- - - - - - -";  // header decoration
        //     string header;

        //     cout << "\n\n\n";	
        //     if (showMolly) {
        //         if (handHisto){
        //             if (forToday){
        //                 histo = molly.histoHandPtsToday;
        //                 header = "Molly's hands today";
        //             } else {
        //                 histo = molly.histoHandPtsAT;
        //                 header = "Molly's hands (all-time)";
        //             }
        //         } else { // default is crib histo
        //             if (forToday){
        //                 histo = molly.histoCribPtsToday;
        //                 header = "Molly's cribs today";
        //             } else {
        //                 histo = molly.histoCribPtsAT;
        //                 header = "Molly's cribs (all-time)";
        //             }
        //         }
        //     }
        //     else if (showJohnny) {
        //         if (handHisto){
        //             if (forToday){
        //                 histo = johnny.histoHandPtsToday;
        //                 header = "Johnny's hands today";
        //             } else {
        //                 histo = johnny.histoHandPtsAT;
        //                 header = "Johnny's hands (all-time)";
        //             }
        //         } else { // default is crib histo
        //             if (forToday){
        //                 histo = johnny.histoCribPtsToday;
        //                 header = "Johnny's cribs today";
        //             } else {
        //                 histo = johnny.histoCribPtsAT;
        //                 header = "Johnny's cribs (all-time)";
        //             }
        //         }
        //     }
        //     else {  // default is combined (both players)
        //         if (handHisto){
        //             if (forToday){
        //                 histo = combinedHistoFrom({molly.histoHandPtsToday, johnny.histoHandPtsToday});
        //                 header = "(Combined) today's hands";
        //             } else {
        //                 histo = combinedHistoFrom({molly.histoHandPtsAT, johnny.histoHandPtsAT});
        //                 header = "(Combined) hands breakdown (all-time)";
        //             }
        //         } else {  // crib histos (combined)
        //             if (forToday){
        //                 histo = combinedHistoFrom({molly.histoCribPtsToday, johnny.histoCribPtsToday});
        //                 header = "(Combined) today's cribs";
        //             } else {
        //                 histo = combinedHistoFrom({molly.histoCribPtsAT, johnny.histoCribPtsAT});
        //                 header = "(Combined) crib breakdown (all-time)";
        //             }
        //         }
        //     }

        //     domain = domainOfHisto(histo);
        //     range = rangeOfHisto(histo);
        //     if (domain < 10)        extraIndent += 1;
        //     else if (useThickBars)  extraIndent += 2;

        //     printCentered(0, headDec + "  " + header + "  " + headDec, 3);

        //     if (presentHorizontally) {
        //         for (int i = 0; i <= domain; i++) {			
        //             if (useThickBars)  cout << "\n     " << multString(histo[i], barChar) << endl;
        //             cout << (i < 10 ? "  " : " ") << i << "  ";
        //             cout << multString(histo[i], barChar) << (showAmounts && histo[i] > 0 ? " " + to_string(histo[i]) : "") << endl;
        //         }
        //     } else {  // present vertically
        //         const string INDENT = useThickBars ? string((SCREEN_WIDTH-(4 * domain+1))/2, ' ') : string((SCREEN_WIDTH-(3 * domain+1))/2, ' ');

        //         cout << INDENT;  // top scale
        //         for (int ptVal = 0; ptVal <= domain; ptVal++) {
        //             if (useThickBars)
        //                 cout << (ptVal < 10 ? to_string(ptVal) + "   " : to_string(ptVal) + "  ");
        //             else
        //                 cout << (ptVal < 10 ? to_string(ptVal) + "  " : to_string(ptVal) + " ");
        //         }

        //         printCentered(1, (useThickBars ?  string(4*domain + 4 + extraIndent, '-') : string(3*domain + 4 + extraIndent, '-')), 2);


        //         for (int freq = range; freq > 0; freq--) {  // the bars
        //             cout << INDENT;
        //             for (int ptVal = 0; ptVal <= domain; ptVal++) {
        //                 if (useThickBars)
        //                     cout << (histo[ptVal] >= freq ? barChar + barChar + "  " : "    ");
        //                 else 
        //                     cout << (histo[ptVal] >= freq ? barChar + barChar + " " : "   ");
        //             }
        //             cout << endl;
        //         }


        //         // bottom scale
        //         printCentered(0, (useThickBars ?  string(4*domain + 4 + extraIndent, '-') : string(3*domain + 4 + extraIndent, '-')), 2);
        //         cout << INDENT;
        //         for (int ptVal = 0; ptVal <= domain; ptVal++) {
        //             if (useThickBars)
        //                 cout << (ptVal < 10 ? to_string(ptVal) + "   " : to_string(ptVal) + "  ");
        //             else
        //                 cout << (ptVal < 10 ? to_string(ptVal) + "  " : to_string(ptVal) + " ");
        //         }
        //     }
        //     string histoMean = to_string(computeMeanFromHisto(histo));
        //     histoMean = histoMean.substr(0, histoMean.size() - 4);  // to only show 2 decimal places
        //     printCentered(3, "Average:  " + histoMean + " pts" + (forToday ? "" : "  (for 2023)"), 4);
        }


        function multString(multiple, st) {  // string (int, string)
            // string multipliedSt = "";
            // for (int i = 0; i < multiple; i++)
            //     multipliedSt += st;
            // return multipliedSt;
        }


        function computeMeanFromHisto(histo) {  // float (vector<int>)
            let numHands = 0;
            let sumPts = 0;
            for (let i = 0; i < histo.length; i++) {
                numHands += histo[i];
                sumPts   += i * histo[i];
            }
            return (sumPts * 1.0) / (numHands * 1.0);
        }


        function domainOfHisto(histo) {  // int (vector<int>)
        // returns the upper bound of the histograms' UTILIZED domain (aka: the highest score achieved)
            let highest = 0;
            for (let i = 0; i < histo.length; i++) {
                if (histo[i] > 0 && i > highest)
                    highest = i;
            }
            return highest;
        }


        function rangeOfHisto(histo) {  // int (vector<int>)
        // returns the biggest frequency found in the histogram
            let biggest = 0;
            for (let i = 0; i < histo.length; i++) {
                if (histo[i] > biggest)
                    biggest = histo[i];
            }
            return biggest;
        }


        function combinedHistoFrom(histos) { // vector<int> (vector<vector<int>>)
        // Combines histograms of the same size. Assumes those passed in are the same size.
            let combined = Array(histos[0].length).fill(0);
            for (let h of histos) {
                for (let i = 0; i < h.length; i++)
                    combined[i] += h[i];
            }
            return combined;
        }


        // search for a string (or any of multiple strings) s2 inside a given string s1
        function srch(s1, s2) {  // bool (string, string) OR (string, vector<string>)
        // BLAH: make this case-insensitive
            
            if (typeof s2 === 'string')  // is s2 in s1?
                return (s1.search(s2) != -1);

            for (const st of s2)  // is any of s2[] in s1?
                if (s1.search(st) != -1)
                    return true;

            return false;
        }


        function determineLoser() {  // Player* ()
        // given a list of both players and given the winner, return a pointer to the loser
            if (players[0].name == winner.name)
                return players[1];
            return players[0];
        }


        function print(s) {
            theForm.outputbox.value += s;
            theForm.outputbox.scrollTop = theForm.outputbox.scrollHeight;
        }


        function printCentered(numNewLinesBefore, message, numNewLinesAfter) {  // void (int, string, int)
            let st = '\n'.repeat(numNewLinesBefore) +
                        ' '.repeat( (SCREEN_WIDTH - message.length) / 2 ) + message +
                        '\n'.repeat(numNewLinesAfter);
            print(st);
        }


        function loadATDataFromFile() {  // void ()
            // cout << "\nLoading player save data . . .  ";
            // fstream saveFile;
            // saveFile.open(BLANK_SAVE_FILE_INPUT_NAME, ios::in);  // use blank test data if it's present
            // if(!saveFile.is_open()){
            //     saveFile.open(SAVE_FILE_NAME, ios::in);  // otherwise use the real data
            //     if(!saveFile.is_open()){
            //         cout << "\n\n*** Error in opening '" << SAVE_FILE_NAME << "' ***\n\n"
            //             << "Exiting program...\n\n\n";
            //         exit(1);
            //     }
            // } else  usingBlankSaveData = true;

            // string line;
            // for (Player* p : players) {
            //     while(getline(saveFile, line)) {
            //         if (line == "")
            //             continue;
                    
            //         if (line == VAR_PREFIX + "name") {
            //             getline(saveFile, line);
            //             p.name = line;
            //         }
            //         else if (line == VAR_PREFIX + "indtAdjstdName"){
            //             getline(saveFile, line);
            //             p.indtAdjstdName = line;
            //         }
            //         else if (line == VAR_PREFIX + "legacyWins"){
            //             getline(saveFile, line);
            //             p.legacyWins = stoi(line);
            //         }
            //         else if (line == VAR_PREFIX + "legacyCribSum"){
            //             getline(saveFile, line);
            //             p.legacyCribSum = stoi(line);
            //         }
            //         else if (line == VAR_PREFIX + "legacyNumHands"){
            //             getline(saveFile, line);
            //             p.legacyNumHands = stoi(line);
            //         }
                        
            //         else if (line == VAR_PREFIX + "histoCutsForFirstCribAT") {
            //             for (int i = 0; i < 13; i++) {
            //                 getline(saveFile, line);
            //                 p.histoCutsForFirstCribAT[i] = stoi(line);
            //             }
            //         }
            //         else if (line == VAR_PREFIX + "histoCutsForMyCribAT") {
            //             for (int i = 0; i < 13; i++) {
            //                 getline(saveFile, line);
            //                 p.histoCutsForMyCribAT[i] = stoi(line);
            //             }
            //         }
            //         else if (line == VAR_PREFIX + "histoHandPtsAT") {
            //             for (int i = 0; i < 30; i++) {
            //                 getline(saveFile, line);
            //                 p.histoHandPtsAT[i] = stoi(line);
            //             }
            //         }
            //         else if (line == VAR_PREFIX + "histoCribPtsAT") {
            //             for (int i = 0; i < 30; i++) {
            //                 getline(saveFile, line);
            //                 p.histoCribPtsAT[i] = stoi(line);
            //             }
            //         }
            //         else if (line == VAR_PREFIX + "histoWinMarginsAT") {
            //             for (int i = 0; i < 120; i++) {
            //                 getline(saveFile, line);
            //                 p.histoWinMarginsAT[i] = stoi(line);
            //             }
            //         }

            //         else if (line == VAR_PREFIX + "numFirstCribsAT"){
            //             getline(saveFile, line);
            //             p.numFirstCribsAT = stoi(line);
            //         }
            //         else if (line == VAR_PREFIX + "numFirstCribsWonAT"){
            //             getline(saveFile, line);
            //             p.numFirstCribsWonAT = stoi(line);
            //         }
            //         else if (line == VAR_PREFIX + "peggedPtsAt"){
            //             getline(saveFile, line);
            //             p.peggedPtsAt = stoi(line);
            //         }

            //         else if (line == VAR_PREFIX + "unusedPtsAT") {
            //             for (int i = 0; i < 4; i++) {
            //                 getline(saveFile, line);
            //                 p.unusedPtsAT[i] = stoi(line);
            //             }
            //         }

            //         else if (line == VAR_PREFIX + "macrogamePtsAT"){
            //             getline(saveFile, line);
            //             p.macrogamePtsAT = stoi(line);
            //         }
            //         else if (line == VAR_PREFIX + "numSessionsPlayedAT"){
            //             getline(saveFile, line);
            //             p.numSessionsPlayedAT = stoi(line);
            //         }
            //         else if (line == VAR_PREFIX + "numHandsAT"){
            //             getline(saveFile, line);
            //             p.numHandsAT = stoi(line);
            //         }
            //         else if (line == VAR_PREFIX + "numCribsAT"){
            //             getline(saveFile, line);
            //             p.numCribsAT = stoi(line);
            //         }
            //         else if (line == VAR_PREFIX + "gamesPlayedAT"){
            //             getline(saveFile, line);
            //             p.gamesPlayedAT = stoi(line);
            //         }
            //         else if (line == VAR_PREFIX + "winsAT"){
            //             getline(saveFile, line);
            //             p.winsAT = stoi(line);
            //         }
            //         else if (line == VAR_PREFIX + "nobsAT"){
            //             getline(saveFile, line);
            //             p.nobsAT = stoi(line);
            //         }
            //         else if (line == VAR_PREFIX + "FOKsAT"){
            //             getline(saveFile, line);
            //             p.FOKsAT = stoi(line);
            //         }
            //         else if (line == VAR_PREFIX + "flushesAT"){
            //             getline(saveFile, line);
            //             p.flushesAT = stoi(line);
            //         }
            //         else if (line == VAR_PREFIX + "superFlushesAT"){
            //             getline(saveFile, line);
            //             p.superFlushesAT = stoi(line);
            //         }

            //         else if (line == "- - - - - - - - - -")
            //             break; // next player...

            //     } // /while there are lines in the file
            // } // /for each player

            // if (usingBlankSaveData)
            //     cout << "BLANK TEST DATA LOADED\n";
            // else  cout << "success :)\n";
        }


        function saveATDataToFile() {  // void ()
        // // save the players' all-time data to file

        //     string saveData = "";

        //     for (Player* p : players) {	
        //         saveData += VAR_PREFIX + "name" + "\n";
        //         saveData += p.name + "\n\n";

        //         saveData += VAR_PREFIX + "indtAdjstdName" + "\n";
        //         saveData += p.indtAdjstdName + "\n\n";

        //         saveData += VAR_PREFIX + "legacyWins" + "\n";
        //         saveData += to_string(p.legacyWins) + "\n\n";

        //         saveData += VAR_PREFIX + "legacyCribSum" + "\n";
        //         saveData += to_string(p.legacyCribSum) + "\n\n";

        //         saveData += VAR_PREFIX + "legacyNumHands" + "\n";
        //         saveData += to_string(p.legacyNumHands) + "\n\n";

        //         saveData += VAR_PREFIX + "histoCutsForFirstCribAT" + "\n";
        //         for (int i = 0; i < 13; i++)
        //             saveData += to_string(p.histoCutsForFirstCribAT[i]) + "\n";
        //         saveData += "\n";
                
        //         saveData += VAR_PREFIX + "histoCutsForMyCribAT" + "\n";
        //         for (int i = 0; i < 13; i++)
        //             saveData += to_string(p.histoCutsForMyCribAT[i]) + "\n";
        //         saveData += "\n";
                
        //         saveData += VAR_PREFIX + "histoHandPtsAT" + "\n";
        //         for (int i = 0; i < 30; i++)
        //             saveData += to_string(p.histoHandPtsAT[i]) + "\n";
        //         saveData += "\n";
                
        //         saveData += VAR_PREFIX + "histoCribPtsAT" + "\n";
        //         for (int i = 0; i < 30; i++)
        //             saveData += to_string(p.histoCribPtsAT[i]) + "\n";
        //         saveData += "\n";
                
        //         saveData += VAR_PREFIX + "histoWinMarginsAT" + "\n";
        //         for (int i = 0; i < 120; i++)
        //             saveData += to_string(p.histoWinMarginsAT[i]) + "\n";
        //         saveData += "\n";
                
        //         saveData += VAR_PREFIX + "numFirstCribsAT" + "\n";
        //         saveData += to_string(p.numFirstCribsAT) + "\n\n";

        //         saveData += VAR_PREFIX + "numFirstCribsWonAT" + "\n";
        //         saveData += to_string(p.numFirstCribsWonAT) + "\n\n";

        //         saveData += VAR_PREFIX + "peggedPtsAt" + "\n";
        //         saveData += to_string(p.peggedPtsAt) + "\n\n";

        //         saveData += VAR_PREFIX + "unusedPtsAT" + "\n";
        //         for (int i = 0; i < 4; i++)
        //             saveData += to_string(p.unusedPtsAT[i]) + "\n";
        //         saveData += "\n";
                
        //         saveData += VAR_PREFIX + "macrogamePtsAT" + "\n";
        //         saveData += to_string(p.macrogamePtsAT) + "\n\n";

        //         saveData += VAR_PREFIX + "numSessionsPlayedAT" + "\n";
        //         saveData += to_string(p.numSessionsPlayedAT) + "\n\n";

        //         saveData += VAR_PREFIX + "numHandsAT" + "\n";
        //         saveData += to_string(p.numHandsAT) + "\n\n";

        //         saveData += VAR_PREFIX + "numCribsAT" + "\n";
        //         saveData += to_string(p.numCribsAT) + "\n\n";

        //         saveData += VAR_PREFIX + "gamesPlayedAT" + "\n";
        //         saveData += to_string(p.gamesPlayedAT) + "\n\n";

        //         saveData += VAR_PREFIX + "winsAT" + "\n";
        //         saveData += to_string(p.winsAT) + "\n\n";

        //         saveData += VAR_PREFIX + "nobsAT" + "\n";
        //         saveData += to_string(p.nobsAT) + "\n\n";

        //         saveData += VAR_PREFIX + "FOKsAT" + "\n";
        //         saveData += to_string(p.FOKsAT)+ "\n\n";

        //         saveData += VAR_PREFIX + "flushesAT" + "\n";
        //         saveData += to_string(p.flushesAT) + "\n\n";

        //         saveData += VAR_PREFIX + "superFlushesAT" + "\n";
        //         saveData += to_string(p.superFlushesAT) + "\n\n";

        //         saveData += "\n\n\n\n- - - - - - - - - -\n\n\n\n\n\n";
        //     } // /for each player

        //     ofstream saveFile;
        //     if (usingBlankSaveData) {
        //         saveFile.open(BLANK_SAVE_FILE_OUTPUT_NAME, ios::out);
        //         cout << "Saving data to 'test_save_data_output.txt' . . .  ";
        //     }
        //     else {
        //         saveFile.open(SAVE_FILE_NAME, ios::out);
        //         cout << "Saving data to 'cribulator_player_save_data.txt' . . .  ";
        //     }
        //     saveFile << saveData;
        //     saveFile.close();
        //     cout << "success :)\n\n\n\n";
        }


        async function getlineMine() {  // string ()
        // performs getline(cin, string) but does not allow null input.
        // It forces the user to enter something.
            do {
                // getline(cin, userInput);
                let userInput = await getUserInput();
                // -----
                if (userInput != "") {
                    if (srch(userInput, CORRECTION_VARIATIONS)) {
                        userWantsToCorrectRound = true;
                        printCentered(0, "~  correction  ~", 1);
                    }
                    return userInput;
                }
                printCentered(1, "Woops: looks like you hit ENTER by mistake.", 2);
                print("What did you mean to input?  ");
            } while(true);
        }
        async function getUserInput() {
            while (! newInputExists)
                await sleep(1000);
            newInputExists = false;
            return mostRecentInput;
        }
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }


        function backupVariables() {  // void ()
        // //if (backupWasJustRestored)
        //     //return;  // no need to backup again: we've just restored this data and are performing a correction

        //     cribberBackup = cribber;
        //     nonCribberBackup = nonCribber;

        //     for (int i = 0; i < players.size(); i++) {
        //         //vector<int> histoCutsForFirstCribAT {vector<int>(13,0)};
        //         playerBackups[i].histoCutsForFirstCribAT = players[i].histoCutsForFirstCribAT;

        //         // vector<int> histoCutsForMyCribAT {vector<int>(13,0)};  // aka starter cards
        //         playerBackups[i].histoCutsForMyCribAT = players[i].histoCutsForMyCribAT;

        //         // vector<int> histoHandPtsAT {vector<int>(30,0)};
        //         playerBackups[i].histoHandPtsAT = players[i].histoHandPtsAT;

        //         // vector<int> histoCribPtsAT {vector<int>(30,0)};
        //         playerBackups[i].histoCribPtsAT = players[i].histoCribPtsAT;

        //         // vector<int> histoWinMarginsAT {vector<int>(120,0)};
        //         playerBackups[i].histoWinMarginsAT = players[i].histoWinMarginsAT;

        //         playerBackups[i].numFirstCribsAT = players[i].numFirstCribsAT;
        //         playerBackups[i].numFirstCribsWonAT = players[i].numFirstCribsWonAT;
        //         playerBackups[i].peggedPtsAt = players[i].peggedPtsAt;

        //         // vector<int> unusedPtsAT = {0,0,0,0};
        //         playerBackups[i].unusedPtsAT = players[i].unusedPtsAT;

        //         playerBackups[i].macrogamePtsAT = players[i].macrogamePtsAT;
        //         playerBackups[i].numSessionsPlayedAT = players[i].numSessionsPlayedAT;
        //         playerBackups[i].numHandsAT = players[i].numHandsAT;
        //         playerBackups[i].numCribsAT = players[i].numCribsAT;
        //         playerBackups[i].gamesPlayedAT = players[i].gamesPlayedAT;
        //         playerBackups[i].winsAT = players[i].winsAT;
        //         playerBackups[i].nobsAT = players[i].nobsAT;
        //         playerBackups[i].FOKsAT = players[i].FOKsAT;
        //         playerBackups[i].flushesAT = players[i].flushesAT;
        //         playerBackups[i].superFlushesAT = players[i].superFlushesAT;

        //         // vector<int> cutsForFirstCribToday;
        //         playerBackups[i].cutsForFirstCribToday = players[i].cutsForFirstCribToday;

        //         // vector<int> histoCutsForMyCribToday {vector<int>(13,0)};
        //         playerBackups[i].histoCutsForMyCribToday = players[i].histoCutsForMyCribToday;

        //         // vector<int> histoHandPtsToday {vector<int>(30,0)};
        //         playerBackups[i].histoHandPtsToday = players[i].histoHandPtsToday;
                
        //         // vector<int> histoCribPtsToday {vector<int>(30,0)};
        //         playerBackups[i].histoCribPtsToday = players[i].histoCribPtsToday;
                
        //         // vector<int> winMarginsToday;
        //         playerBackups[i].winMarginsToday = players[i].winMarginsToday;

        //         playerBackups[i].numFirstCribsToday = players[i].numFirstCribsToday;
        //         playerBackups[i].numFirstCribsWonToday = players[i].numFirstCribsWonToday;
        //         playerBackups[i].peggedPtsToday = players[i].peggedPtsToday;

        //         //vector<int> unusedPtsToday = {0,0,0,0};
        //         playerBackups[i].unusedPtsToday = players[i].unusedPtsToday;
                
        //         playerBackups[i].losingPositionToday = players[i].losingPositionToday;
        //         playerBackups[i].macrogamePtsToday = players[i].macrogamePtsToday;
        //         playerBackups[i].numHandsToday = players[i].numHandsToday;
        //         playerBackups[i].numCribsToday = players[i].numCribsToday;
        //         playerBackups[i].gamesPlayedToday = players[i].gamesPlayedToday;
        //         playerBackups[i].winsToday = players[i].winsToday;
        //         playerBackups[i].nobsToday = players[i].nobsToday;
        //         playerBackups[i].FOKsToday = players[i].FOKsToday;
        //         playerBackups[i].flushesToday = players[i].flushesToday;
        //         playerBackups[i].superFlushesToday = players[i].superFlushesToday;
        //         playerBackups[i].handPtsThisGame = players[i].handPtsThisGame;
        //         playerBackups[i].cribPtsThisGame = players[i].cribPtsThisGame;
        //         playerBackups[i].numNibsThisGame = players[i].numNibsThisGame;
        //         playerBackups[i].peggedPtsThisGame = players[i].peggedPtsThisGame;

        //         //vector<int> unusedPtsThisGame = {0,0,0,0};
        //         playerBackups[i].unusedPtsThisGame = players[i].unusedPtsThisGame;
                
        //         playerBackups[i].numHandsThisGame = players[i].numHandsThisGame;
        //         playerBackups[i].numCribsThisGame = players[i].numCribsThisGame;
        //     }
        //     userWantsToCorrect1stCribCut = false;  // if we've reached the call to this function,
        //                                         // the correction request doesn't have to do with 
        //                                         // fixing the cut to see who gets crib first
        }


        function restoreBackupOfVariables() {  // void ()
            // cribber = cribberBackup;
            // nonCribber = nonCribberBackup;

            // for (int i = 0; i < players.size(); i++) {
            //     //vector<int> histoCutsForFirstCribAT {vector<int>(13,0)};
            //     players[i].histoCutsForFirstCribAT = playerBackups[i].histoCutsForFirstCribAT;

            //     // vector<int> histoCutsForMyCribAT {vector<int>(13,0)};  // aka starter cards
            //     players[i].histoCutsForMyCribAT = playerBackups[i].histoCutsForMyCribAT;

            //     // vector<int> histoHandPtsAT {vector<int>(30,0)};
            //     players[i].histoHandPtsAT = playerBackups[i].histoHandPtsAT;

            //     // vector<int> histoCribPtsAT {vector<int>(30,0)};
            //     players[i].histoCribPtsAT = playerBackups[i].histoCribPtsAT;

            //     // vector<int> histoWinMarginsAT {vector<int>(120,0)};
            //     players[i].histoWinMarginsAT = playerBackups[i].histoWinMarginsAT;

            //     players[i].numFirstCribsAT = playerBackups[i].numFirstCribsAT;
            //     players[i].numFirstCribsWonAT = playerBackups[i].numFirstCribsWonAT;
            //     players[i].peggedPtsAt = playerBackups[i].peggedPtsAt;

            //     // vector<int> unusedPtsAT = {0,0,0,0};
            //     players[i].unusedPtsAT = playerBackups[i].unusedPtsAT;

            //     players[i].macrogamePtsAT = playerBackups[i].macrogamePtsAT;
            //     players[i].numSessionsPlayedAT = playerBackups[i].numSessionsPlayedAT;
            //     players[i].numHandsAT = playerBackups[i].numHandsAT;
            //     players[i].numCribsAT = playerBackups[i].numCribsAT;
            //     players[i].gamesPlayedAT = playerBackups[i].gamesPlayedAT;
            //     players[i].winsAT = playerBackups[i].winsAT;
            //     players[i].nobsAT = playerBackups[i].nobsAT;
            //     players[i].FOKsAT = playerBackups[i].FOKsAT;
            //     players[i].flushesAT = playerBackups[i].flushesAT;
            //     players[i].superFlushesAT = playerBackups[i].superFlushesAT;

            //     // vector<int> cutsForFirstCribToday;
            //     players[i].cutsForFirstCribToday = playerBackups[i].cutsForFirstCribToday;

            //     // vector<int> histoCutsForMyCribToday {vector<int>(13,0)};
            //     players[i].histoCutsForMyCribToday = playerBackups[i].histoCutsForMyCribToday;

            //     // vector<int> histoHandPtsToday {vector<int>(30,0)};
            //     players[i].histoHandPtsToday = playerBackups[i].histoHandPtsToday;
                
            //     // vector<int> histoCribPtsToday {vector<int>(30,0)};
            //     players[i].histoCribPtsToday = playerBackups[i].histoCribPtsToday;
                
            //     // vector<int> winMarginsToday;
            //     players[i].winMarginsToday = playerBackups[i].winMarginsToday;

            //     players[i].numFirstCribsToday = playerBackups[i].numFirstCribsToday;
            //     players[i].numFirstCribsWonToday = playerBackups[i].numFirstCribsWonToday;
            //     players[i].peggedPtsToday = playerBackups[i].peggedPtsToday;

            //     //vector<int> unusedPtsToday = {0,0,0,0};
            //     players[i].unusedPtsToday = playerBackups[i].unusedPtsToday;
                
            //     players[i].losingPositionToday = playerBackups[i].losingPositionToday;
            //     players[i].macrogamePtsToday = playerBackups[i].macrogamePtsToday;
            //     players[i].numHandsToday = playerBackups[i].numHandsToday;
            //     players[i].numCribsToday = playerBackups[i].numCribsToday;
            //     players[i].gamesPlayedToday = playerBackups[i].gamesPlayedToday;
            //     players[i].winsToday = playerBackups[i].winsToday;
            //     players[i].nobsToday = playerBackups[i].nobsToday;
            //     players[i].FOKsToday = playerBackups[i].FOKsToday;
            //     players[i].flushesToday = playerBackups[i].flushesToday;
            //     players[i].superFlushesToday = playerBackups[i].superFlushesToday;
            //     players[i].handPtsThisGame = playerBackups[i].handPtsThisGame;
            //     players[i].cribPtsThisGame = playerBackups[i].cribPtsThisGame;
            //     players[i].numNibsThisGame = playerBackups[i].numNibsThisGame;
            //     players[i].peggedPtsThisGame = playerBackups[i].peggedPtsThisGame;

            //     //vector<int> unusedPtsThisGame = {0,0,0,0};
            //     players[i].unusedPtsThisGame = playerBackups[i].unusedPtsThisGame;
                
            //     players[i].numHandsThisGame = playerBackups[i].numHandsThisGame;
            //     players[i].numCribsThisGame = playerBackups[i].numCribsThisGame;
            // }
            // cribber.histoCutsForMyCribToday[lastCutCardIndex]--;  // jank correction needed due to where the backup snapshot is taken
            // cribber.histoCutsForMyCribAT[lastCutCardIndex]--;
            // userWantsToCorrectRound = false;
            // //backupWasJustRestored = true;
            // printCentered(0, "Re-enter that round", 1);
            // cout << cribber.name << "'s crib\n";
        }


        function undoLastDrawForWhoGets1stCrib() {  // void ()
            // for (Player* p : players) {
            //     p.histoCutsForFirstCribAT[await cardIndexOf(p.cutsForFirstCribToday.back())]--;
            //     p.cutsForFirstCribToday.pop_back();
            // }
        }


        function userWantsToCorrect1stCribDraw() {  // bool ()
            // if (players[0].numHandsThisGame != 0)
            //     return false;

            // cout << "\n   What do you want to correct?\n\n"
            //     << "      1) previous game's last hand\n"
            //     << "      2) card draw for this game's first crib\n\n"
            //     << "   Enter choice:  ";
            // string correctionChoice = await getlineMine();
            // cout << "\n\n";
            // if (correctionChoice == "1")
            //     return false;

            // userWantsToCorrectRound = false;
            // userWantsToCorrect1stCribCut = true;
            // undoLastDrawForWhoGets1stCrib();
            // return true;
return false;
        }


        async function mystoi(st)  {  // int (string)
        // an error-catching version of stoi(), used to catch cases where user enters letters
        // ...before the number, so that the program doesn't crash. Forces the user to
        // ...re-enter the input in those cases.
            let intVersion = Number(st);
            if (isNaN(intVersion)) {  // can also use catch(...) to catch ALL exception types
                if (st == previousInvalidInput)
                    return previousInvalidInputFix;

                previousInvalidInput = st;
                printCentered(1, "Error: invalid input '" + st + "' detected", 2);
                print("What did you mean?  ");
                let input = await getUserInput();
                intVersion = await mystoi(input);
            }

            previousInvalidInputFix = intVersion;
            return intVersion;
        }


        function handleStatsRequests(userInput) {  // bool (string)
        // // Precondition:  players is {*molly, *johnny}, in that order
        // // Postcondition:  Displays any stats requested. 
        // //                 Returns true if they were requested, false otherwise.
        //     if (srch(userInput, HISTO_VARIATIONS)) {
        //         printHistogram(userInput);
        //         userWantsToCorrectRound = false;  // ignore any correction requests in input that has a histo request
        //         return true;
        //     }
        //     return false;
return false;
        }

        main();
    </script>


    <!-- <script defer="" type="text/javascript" src="cribulator.js"></script> -->
</body>
</html>